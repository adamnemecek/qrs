use alga::general::{RealField, ComplexField};
use blas_traits::BlasScalar;
use num_complex::Complex;
use vec_ode::{ODEState, ODESolver, ODESolverBase, LinearCombination, AdaptiveODESolver};
use crate::base::quantum::{QRep};
use crate::base::dense::*;
use crate::util::{EigResolver, EigJob, EigRangeData};
use crate::util::TimeDepMatrix;
use std::iter::FromIterator;
use num_traits::Float;
use vec_ode::exp::{ExponentialSplit, Commutator, NormedExponentialSplit};
use vec_ode::exp::{ExpSplitMidpointSolver, MidpointExpLinearSolver};
use vec_ode::exp::magnus::MagnusExpLinearSolver;
use vec_ode::exp::cfm::ExpCFMSolver;
use nalgebra::{Dynamic, Matrix, U1, VecStorage};
use itertools::Itertools;

///Defines the exponential e^{-i H} for a Hermitian operator H
/// For Split ODE solvers
pub struct DenseExpiSplit<T>
where Complex<T> : BlasScalar
{
    n: usize,
    eiger: EigResolver<Complex<T>>
}

impl<T> DenseExpiSplit<T>
where Complex<T> : BlasScalar
{
    pub fn new(n: u32) -> Self{
        Self{n: n as usize, eiger: EigResolver::new_eiger(n, EigJob::ValsVecs, EigRangeData::all())}
    }
}

impl<T: RealField+Float> ExponentialSplit<T, Complex<T>, Ket<T>> for DenseExpiSplit<T>
where Complex<T> : BlasScalar + ComplexField<RealField=T>
{
    type L = Op<T>;
    type U = (Ket<T>, Op<T>);

    fn lin_zero(&self) -> Self::L {
        Op::zeros(self.n, self.n)
    }

    fn exp(&mut self, l: &Op<T>) -> (Ket<T>, Op<T>){
        self.eiger.borrow_matrix().copy_from(l);
        self.eiger.eig();

        let (vals, vecs ) = (self.eiger.vals().clone(),
                             self. eiger.vecs().clone());

        let expivals: Vec<Complex<T>> = Vec::from_iter(
            vals.into_iter().map(|v|
                Complex::exp(&(-Complex::i() * Complex::from(v))) ));
        let expivals = Ket::from_column_slice(&expivals);
        (expivals, vecs)
    }

    fn map_exp(&mut self, u: & Self::U, x: & Ket<T>) -> Ket<T>{
        &u.1 * &u.0.component_mul(&u.1.ad_mul(x))
    }

    fn multi_exp(&mut self, l: &Op<T>, k_arr: &[Complex<T>]) -> Vec<Self::U>{
        self.eiger.borrow_matrix().copy_from(l);
        self.eiger.eig();

        let (vals, vecs ) = (self.eiger.vals().clone(),
                             self. eiger.vecs().clone());

        let mut u_vec = Vec::new();
        for &k in k_arr{
            let expivals : Vec<Complex<T>> = vals.iter().map(|v|  Complex::exp(&(-Complex::i() * k * Complex::from(v))))
                .collect_vec();
            let expivals_arr = Ket::from_column_slice(&expivals);
            u_vec.push((expivals_arr, vecs.clone()))
        }

        u_vec
    }
}


impl<T: RealField+Float> Commutator<T, Complex<T>, Ket<T>> for DenseExpiSplit<T>
where Complex<T> : BlasScalar + ComplexField<RealField=T>{
    /// The expi bracket is defined as
    /// [LA, LB] = -i[A, B]
    /// consistent with the Lie algebra generated by LA = -i A and LB = -i B
    ///
    /// exp (a LA + b LB + c[LA, LB] + ...)
    /// exp ( a (-i A) + b (-i B) - c [A ,B] + ...)
    /// = expi( a A + b B - c i [A, B] + ...)
    fn commutator(&self, la: &Op<T>, lb: &Op<T>) -> Op<T>{
        let mut c : Op<T> = la * lb - lb * la;
        c *= -Complex::i();
        c
    }
}

impl<T: RealField+Float> NormedExponentialSplit<T, Complex<T>, Ket<T>> for DenseExpiSplit<T>
where Complex<T> : BlasScalar + ComplexField<RealField=T>{
    fn norm(&self, x: &Ket<T>) -> T{
        x.norm()  // / (T::from_subset(&(x.len() as f64)))
    }
}

pub fn solve_se_exp<'a, R: RealField+Float>(
    H: &'a TimeDepMatrix<'a, Complex<R>>,
    t0: R, tf: R, psi0: Ket<R>, dt: R
) -> Ket<R>
    where Complex<R> : BlasScalar + ComplexField<RealField=R>
{
    let f = |t: R| { H.eval(t.clone()) };
    let n = psi0.len() as u32;
    let mut solver = MidpointExpLinearSolver::new(
        f, t0, tf, psi0, dt, DenseExpiSplit::new(n));
    while let ODEState::Ok(_) = solver.step(){
        0;
    }

    let (_t, psi) = solver.into_current();

    psi
}

pub fn solve_se_me42<'a, R: RealField+Float>(
    H: &'a TimeDepMatrix<'a, Complex<R>>,
    t0: R, tf: R, psi0: Ket<R>, dt: R
) -> Ket<R>
    where Complex<R> : BlasScalar + ComplexField<RealField=R>
{
    let f = |t_arr: &[R]| {
        Vec::from_iter(
        t_arr.iter().map( |t|H.eval(t.clone()) ) )};

    let n = psi0.len() as u32;
    let mut solver = MagnusExpLinearSolver::new(
        f, t0, tf, psi0,  DenseExpiSplit::new(n))
        .with_tolerance(R::from_subset(&1.0e-6), R::from_subset(&1.0e-6))
        .with_step_range(dt*R::from_subset(&1.0e-4),
                         dt*R::from_subset(&1.0e4))
        .with_init_step(dt);
    while let ODEState::Ok(_) = solver.step(){
        0;
    }

    let (_t, psi) = solver.into_current();

    psi
}

pub fn solve_se_cfm42<'a, R: RealField+Float>(
    H: &'a TimeDepMatrix<'a, Complex<R>>,
    t0: R, tf: R, psi0: Ket<R>, dt: R
) -> Ket<R>
    where Complex<R> : BlasScalar + ComplexField<RealField=R>
{
    let f = |t_arr: &[R], _| {
        Vec::from_iter(
            t_arr.iter().map( |t|H.eval(t.clone()) ) )};
    let norm_fn = |v: &Ket<R>|{ v.norm() };
    let n = psi0.len() as u32;
    let mut solver = ExpCFMSolver::new(
        f, norm_fn,t0, tf, psi0,  dt,DenseExpiSplit::new(n))
        .with_tolerance(R::from_subset(&1.0e-6), R::from_subset(&1.0e-6))
        .with_step_range(dt*R::from_subset(&1.0e-4),
                         dt*R::from_subset(&1.0e4))
        .with_init_step(dt);
    ;
    while let ODEState::Ok(_) = solver.step(){
        0;
    }

    let (_t, psi) = solver.into_current();

    psi
}

pub fn solve_se_split<'a, R: RealField+Float>(
    HA: &'a TimeDepMatrix<'a, Complex<R>>, HB: &'a TimeDepMatrix<'a, Complex<R>>,
    t0: R, tf: R, psi0: Ket<R>, dt: R
) -> Ket<R>
where Complex<R> : BlasScalar + ComplexField<RealField=R>
{
    let f = |t: R| {(HA.eval(t.clone()), HB.eval(t.clone())) };
    let n = psi0.len() as u32;
    let mut solver = ExpSplitMidpointSolver::new(
        f, t0, tf, psi0, dt, DenseExpiSplit::new(n), DenseExpiSplit::new(n));
    while let ODEState::Ok(_) = solver.step(){
        0;
    }

    let (_t, psi) = solver.into_current();

    psi
}

#[cfg(test)]
mod tests{
    use num_complex::Complex;
    use num_complex::Complex64 as c64;
    use crate::base::dense::*;
    use crate::base::pauli::dense as pauli;
    use crate::util::{TimeDepMatrixTerm, TimeDepMatrix};
    use crate::ode::dense::{solve_se_split, solve_se_exp, solve_se_me42, solve_se_cfm42};
    use crate::ode::dense::DenseExpiSplit;
    use vec_ode::exp::ExponentialSplit;

    #[test]
    fn test_se_split(){
        let tf = 1002.0;
        let dt = 0.005;
        let mut sp_haml = DenseExpiSplit::new(2);
        let sx = pauli::sx::<f64>();
        let sz = pauli::sz::<f64>();

        let fx = |t: f64| Complex::from(10.0*(0.5 - (t/tf)));
        let fz = |t: f64| Complex::from(0.5);

        let hx = TimeDepMatrixTerm::new(&sx, &fx);
        let hz = TimeDepMatrixTerm::new(&sz, &fz);

        let haml_a = TimeDepMatrix{terms: vec![hx.clone()]};
        let haml_b = TimeDepMatrix{terms: vec![hz.clone()]};
        let haml_sum = TimeDepMatrix{terms: vec![hx, hz]};
        let exp_haml = sp_haml.exp(&haml_sum.eval(tf));
        let psi0 = pauli::sx_eig(-1);

        println!("Testing SE Split...");
        let psi_f = solve_se_split(
            &haml_a, &haml_b, 0.0, tf,  psi0.clone(), dt);
        println!("Split Method: \n{}", psi_f.map(|z| z.norm_sqr()));
        let psi_2 = solve_se_exp(&haml_sum, 0.0, tf, psi0.clone(), dt);
        println!("Midpoint Method:\n{}", psi_2.map(|z| z.norm_sqr()));
        let psi_3 = solve_se_cfm42(&haml_sum, 0.0, tf, psi0.clone(), dt);
        println!("CFM-4 Method:\n{}", psi_3.map(|z| z.norm_sqr()));
        let psi_4 = solve_se_me42(&haml_sum, 0.0, tf, psi0, dt);
        println!("Magnus-4 Method:\n{}", psi_4.map(|z| z.norm_sqr()));

    }
}