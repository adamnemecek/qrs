use std::iter::FromIterator;

use itertools::Itertools;
use num_complex::Complex;
use num_traits::Float;
use vec_ode::{AdaptiveODESolver, LinearCombination, ODESolver, ODESolverBase, ODEState};
use vec_ode::exp::{Commutator, ExponentialSplit, NormedExponentialSplit};
use vec_ode::exp::{ExpSplitMidpointSolver, MidpointExpLinearSolver};
use vec_ode::exp::cfm::ExpCFMSolver;
use vec_ode::exp::magnus::MagnusExpLinearSolver;

use qrs_core::{ComplexScalar, RealScalar};
use qrs_core::eig::dmatrix::EigScalar;
use qrs_core::eig::EigJob;
//use crate::base::quantum::{QRep};
use qrs_core::eig::QEiger;
use qrs_core::reps::matrix::*;

use crate::util::{EigRangeData, EigResolver};
use crate::util::TimeDepMatrix;

///Defines the exponential e^{-i H} for a Hermitian operator H
/// For Split ODE solvers
pub struct DenseExpiSplit<T: RealScalar>
where Complex<T> : EigScalar<R=T>
{
    n: usize,
    eiger: EigResolver<Complex<T>>
}

impl<T : RealScalar> DenseExpiSplit<T>
where Complex<T> : EigScalar<R=T>
{
    pub fn new(n: u32) -> Self{
        Self{n: n as usize, eiger: EigResolver::new_eiger(n, EigJob::ValsVecs, EigRangeData::all())}
    }
}

impl<T: RealScalar+Float> ExponentialSplit<T, Complex<T>, Ket<Complex<T>>> for DenseExpiSplit<T>
where Complex<T> : EigScalar<R=T>
{
    type L = Op<Complex<T>>;
    type LC = LC<Complex<T>>;
    type U = (Ket<Complex<T>>, Op<Complex<T>>);

    fn lin_zero(&self) -> Self::L {
        Op::zeros(self.n, self.n)
    }

    fn exp(&mut self, l: Op<Complex<T>>) -> (Ket<Complex<T>>, Op<Complex<T>>){
        let (vals, vecs ) = QEiger::<Complex<T>, DenseQRep<Complex<T>>>::eigh(&mut self.eiger, &l);
        // self.eiger.borrow_matrix().copy_from(&l);
        // self.eiger.eig();
        //
        // let (vals, vecs ) = (self.eiger.vals().clone(),
        //                      self. eiger.vecs().clone());

        let expivals: Vec<Complex<T>> = Vec::from_iter(
            vals.into_iter().map(|v|
                Complex::exp(&(-Complex::i() * Complex::from(v))) ));
        let expivals = Ket::from_column_slice(&expivals);
        (expivals, vecs)
    }

    fn map_exp(&mut self, u: & Self::U, x: & Ket<Complex<T>>) -> Ket<Complex<T>>{
        &u.1 * &u.0.component_mul(&u.1.ad_mul(x))
    }

    fn multi_exp(&mut self, l: Op<Complex<T>>, k_arr: &[Complex<T>]) -> Vec<Self::U>{
        let (vals, vecs ) = QEiger::<Complex<T>, DenseQRep<Complex<T>>>::eigh(&mut self.eiger, &l);

        // self.eiger.borrow_matrix().copy_from(&l);
        // self.eiger.eig();
        //
        // let (vals, vecs ) = (self.eiger.vals().clone(),
        //                      self. eiger.vecs().clone());

        let mut u_vec = Vec::new();
        for &k in k_arr{
            let expivals : Vec<Complex<T>> = vals.iter().map(
                |v|  Complex::exp(&(-Complex::i() * k * Complex::from(v))))
                .collect_vec();
            let expivals_arr = Ket::from_column_slice(&expivals);
            u_vec.push((expivals_arr, vecs.clone()))
        }

        u_vec
    }
}


impl<T: RealScalar+Float> Commutator<T, Complex<T>, Ket<Complex<T>>> for DenseExpiSplit<T>
where Complex<T> : EigScalar<R=T>{
    /// The expi bracket is defined as
    /// [LA, LB] = -i[A, B]
    /// consistent with the Lie algebra generated by LA = -i A and LB = -i B
    ///
    /// exp (a LA + b LB + c[LA, LB] + ...)
    /// exp ( a (-i A) + b (-i B) - c [A ,B] + ...)
    /// = expi( a A + b B - c i [A, B] + ...)
    fn commutator(&self, la: &Op<Complex<T>>, lb: &Op<Complex<T>>) -> Op<Complex<T>>{
        let mut c : Op<Complex<T>> = la * lb - lb * la;
        c *= -Complex::i();
        c
    }
}

impl<T: RealScalar+Float> NormedExponentialSplit<T, Complex<T>, Ket<Complex<T>>> for DenseExpiSplit<T>
where Complex<T> : EigScalar<R=T>{
    fn norm(&self, x: &Ket<Complex<T>>) -> T{
        x.norm()  // / (T::from_subset(&(x.len() as f64)))
    }
}

#[allow(non_snake_case)]
pub fn solve_se_exp<'a, R: RealScalar+Float>(
    H: &'a TimeDepMatrix<'a, Complex<R>>,
    t0: R, tf: R, psi0: Ket<Complex<R>>, dt: R
) -> Ket<Complex<R>>
    where Complex<R> : EigScalar<R=R>
{
    let f = |t: R| { H.eval(t.clone()) };
    let n = psi0.len() as u32;
    let mut solver = MidpointExpLinearSolver::new(
        f, t0, tf, psi0, dt, DenseExpiSplit::new(n));
    while let ODEState::Ok(_) = solver.step(){
        0;
    }

    let (_t, psi) = solver.into_current();

    psi
}

#[allow(non_snake_case)]
pub fn solve_se_me42<'a, R: RealScalar+Float>(
    H: &'a TimeDepMatrix<'a, Complex<R>>,
    t0: R, tf: R, psi0: Ket<Complex<R>>, dt: R
) -> Ket<Complex<R>>
    where Complex<R> : EigScalar<R=R>
{
    let f = |t_arr: &[R]| {
        Vec::from_iter(
        t_arr.iter().map( |t|H.eval(t.clone()) ) )};

    let n = psi0.len() as u32;
    let mut solver = MagnusExpLinearSolver::new(
        f, t0, tf, psi0,  DenseExpiSplit::new(n))
        .with_tolerance(R::from_subset(&1.0e-6), R::from_subset(&1.0e-6))
        .with_step_range(dt*R::from_subset(&1.0e-4),
                         dt*R::from_subset(&1.0e4))
        .with_init_step(dt);
    while let ODEState::Ok(_) = solver.step(){
        0;
    }

    let (_t, psi) = solver.into_current();

    psi
}
#[allow(non_snake_case)]
pub fn solve_se_cfm42<'a, R: RealScalar+Float>(
    H: &'a TimeDepMatrix<'a, Complex<R>>,
    t0: R, tf: R, psi0: Ket<Complex<R>>, dt: R
) -> Ket<Complex<R>>
    where Complex<R> : EigScalar<R=R>
{
    let f = |t_arr: &[R], _| {
        Vec::from_iter(
            t_arr.iter().map( |t|H.eval(t.clone()) ) )};
    let norm_fn = |v: &Ket<Complex<R>>|{ v.norm() };
    let n = psi0.len() as u32;
    let mut solver = ExpCFMSolver::new(
        f, norm_fn,t0, tf, psi0,  dt,DenseExpiSplit::new(n))
        .with_tolerance(R::from_subset(&1.0e-6), R::from_subset(&1.0e-6))
        .with_step_range(dt*R::from_subset(&1.0e-4),
                         dt*R::from_subset(&1.0e4))
        .with_init_step(dt);

    while let ODEState::Ok(_) = solver.step(){
        0;
    }

    let (_t, psi) = solver.into_current();

    psi
}

#[allow(non_snake_case)]
pub fn solve_se_split<'a, R: RealScalar+Float>(
    HA: &'a TimeDepMatrix<'a, Complex<R>>, HB: &'a TimeDepMatrix<'a, Complex<R>>,
    t0: R, tf: R, psi0: Ket<Complex<R>>, dt: R
) -> Ket<Complex<R>>
where Complex<R> : EigScalar<R=R>
{
    let f = |t: R| {(HA.eval(t.clone()), HB.eval(t.clone())) };
    let n = psi0.len() as u32;
    let mut solver = ExpSplitMidpointSolver::new(
        f, t0, tf, psi0, dt, DenseExpiSplit::new(n), DenseExpiSplit::new(n));
    while let ODEState::Ok(_) = solver.step(){
        0;
    }

    let (_t, psi) = solver.into_current();

    psi
}

#[cfg(test)]
mod tests{
    use num_complex::Complex;
    use num_complex::Complex64 as c64;
    use vec_ode::exp::ExponentialSplit;

    use qrs_core::reps::dense::*;

    use crate::base::pauli::matrix as pauli;
    use crate::ode::dense::{solve_se_cfm42, solve_se_exp, solve_se_me42, solve_se_split};
    use crate::ode::dense::DenseExpiSplit;
    use crate::util::{TimeDepMatrix, TimeDepMatrixTerm};

    #[test]
    fn test_se_split(){
        let tf = 1002.0;
        let dt = 0.005;
        let mut sp_haml = DenseExpiSplit::new(2);
        let sx = pauli::sx::<f64>();
        let sz = pauli::sz::<f64>();

        let fx = |t: f64| Complex::from(10.0*(0.5 - (t/tf)));
        let fz = |t: f64| Complex::from(0.5);

        let hx = TimeDepMatrixTerm::new(&sx, &fx);
        let hz = TimeDepMatrixTerm::new(&sz, &fz);

        let haml_a = TimeDepMatrix{terms: vec![hx.clone()]};
        let haml_b = TimeDepMatrix{terms: vec![hz.clone()]};
        let haml_sum = TimeDepMatrix{terms: vec![hx, hz]};
        let exp_haml = sp_haml.exp(haml_sum.eval(tf));
        let psi0 = pauli::sx_eig(-1);

        println!("Testing SE Split...");
        let psi_f = solve_se_split(
            &haml_a, &haml_b, 0.0, tf,  psi0.clone(), dt);
        println!("Split Method: \n{}", psi_f.map(|z| z.norm_sqr()));
        let psi_2 = solve_se_exp(&haml_sum, 0.0, tf, psi0.clone(), dt);
        println!("Midpoint Method:\n{}", psi_2.map(|z| z.norm_sqr()));
        let psi_3 = solve_se_cfm42(&haml_sum, 0.0, tf, psi0.clone(), dt);
        println!("CFM-4 Method:\n{}", psi_3.map(|z| z.norm_sqr()));
        let psi_4 = solve_se_me42(&haml_sum, 0.0, tf, psi0, dt);
        println!("Magnus-4 Method:\n{}", psi_4.map(|z| z.norm_sqr()));

    }
}