use std::iter::FromIterator;

use expm::Expm;
use itertools::Itertools;
use lapack_traits::LapackScalar;
use log::warn;
use nalgebra::DMatrix;
use ndarray::Array2;
use ndarray::ArrayView2;
use num_complex::Complex as C;
use num_traits::Float;
use num_traits::real::Real;
use vec_ode::exp::{Commutator, ExponentialSplit};
use vec_ode::LinearCombination;

use qrs_core::eig::dmatrix::EigScalar;
use qrs_core::eig::{EigJob, EigRange};
use qrs_core::eig::QEiger;
//use qrs_core::reps::dense::*;
use qrs_core::reps::matrix::*;

use crate::{ComplexField, ComplexScalar, RealScalar};
use crate::util::{change_basis, EigRangeData, EigResolver};
use crate::util::{outer_zip_to, unchange_basis};

///Defines the exponential e^{-i H} for a Hermitian operator H
/// For Split ODE solvers
pub struct DenMatExpiSplit<T: RealScalar>
    where C<T> : EigScalar<R=T>
{
    n: usize,
    eiger: EigResolver<C<T>>
}

impl<T: RealScalar> DenMatExpiSplit<T>
    where C<T> : EigScalar<R=T>
{
    pub fn new(n: u32) -> Self{
        Self{n: n as usize, eiger: QEiger::<C<T>,  DenseQRep<C<T>>>
                ::make_eiger((n as usize, n as usize), EigJob::ValsVecs, EigRange::All),
        }
    }
}


impl<T: RealScalar+Float> ExponentialSplit<T, C<T>, Op<C<T>>> for DenMatExpiSplit<T>
    where C<T> : EigScalar<R=T>
{
    type L = Op<C<T>>;
    type LC = LC<C<T>>;
    type U = (Op<C<T>>, Op<C<T>>);

    fn lin_zero(&self) -> Op<C<T>> {
        Op::zeros(self.n, self.n)
    }

    fn exp(&mut self, l: Op<C<T>>) -> (Op<C<T>>, Op<C<T>>){
        let (vals, vecs) = self.eiger.eigh(&l);
        let vals = Ket::from_vec(vals);
        // self.eiger.borrow_matrix().copy_from(&l);
        // self.eiger.eig();

        // let (vals, vecs ) = (self.eiger.vals().clone(),
        //                      self. eiger.vecs().clone());
        let mut freqs : Op<T> = Op::zeros(self.n, self.n);
        outer_zip_to(&vals, &vals, & mut freqs, |a, b| *b - *a);

        let expifreqs: Vec<C<T>> = Vec::from_iter(
            freqs.into_iter().map(|v|
                C::exp(&(-C::i() * C::from(v))) ));

        let expifreqs = Op::from_column_slice(self.n, self.n, &expifreqs);

        (expifreqs, vecs)
    }

    fn map_exp(&mut self, u: & Self::U, x: & Op<C<T>>) -> Op<C<T>>{
        let mut y = change_basis(x, &u.1);
        y.component_mul_assign(&u.0);
        unchange_basis( &y , &u.1)
    }

    fn multi_exp(&mut self, l: Op<C<T>>, k_arr: &[C<T>]) -> Vec<Self::U>{
        // self.eiger.borrow_matrix().copy_from(&l);
        // self.eiger.eig();
        //
        // let (vals, vecs ) = (self.eiger.vals().clone(),
        //                      self. eiger.vecs().clone());
        let (vals, vecs) = self.eiger.eigh(&l);
        let vals = Ket::from_vec(vals);
        let mut freqs : DMatrix<T> = DMatrix::zeros(self.n, self.n);
        outer_zip_to(&vals, &vals, & mut freqs, |a, b| *b - *a);

        let mut u_vec = Vec::new();

        for &k in k_arr{
            let expifreqs : Vec<C<T>> = freqs.iter()
                .map(|v|  C::exp(&(-C::i() * k * C::from(v))))
                .collect_vec();
            let expifreqs_arr = Op::from_column_slice(self.n, self.n, &expifreqs);

            u_vec.push((expifreqs_arr, vecs.clone()))
        }

        u_vec
    }
}

pub struct DenMatPerturbExpSplit<T: RealScalar>
    where C<T> : EigScalar<R=T>{
    n: usize,
    expm: Expm<C<T>>
}
impl<T: RealScalar> DenMatPerturbExpSplit<T>
where C<T> : EigScalar<R=T>{
    pub fn new(n: u32) -> Self{
        Self{n: n as usize, expm: Expm::new(n as usize )}
    }
}
impl<T: RealScalar> ExponentialSplit<T, C<T>, Op<C<T>>> for DenMatPerturbExpSplit<T>
where C<T> : EigScalar<R=T>
{
    type L = Op<C<T>>;
    type LC = LC<C<T>>;
    type U = Op<C<T>>;

    fn lin_zero(&self) -> Self::L {
        Op::zeros(self.n, self.n)
    }

    fn exp(&mut self, l: Self::L) -> Self::U {
        let n = self.n;
        let arr = ArrayView2::from_shape((n,n), & l.as_slice()).unwrap();
        let mut exp_arr = Array2::zeros((n,n));
        self.expm.expm(&arr, &mut exp_arr);
        let exp_map: Op<C<T>> = Op::from_vec(n, n, exp_arr.into_owned().into_raw_vec());

        exp_map
    }

    fn map_exp(&mut self, u: &Self::U, x: &Op<C<T>>) -> Op<C<T>> {
        //u.ad_mul(x) * u
        u * (x * &u.adjoint())
    }
}


impl<T: RealScalar+Float> Commutator<T, C<T>, Op<C<T>>> for DenMatExpiSplit<T>
    where C<T> : EigScalar<R=T>{
    /// The expi bracket is defined as
    /// [LA, LB] = -i[A, B]
    /// consistent with the Lie algebra generated by LA = -i A and LB = -i B
    ///
    /// exp (a LA + b LB + c[LA, LB] + ...)
    /// exp ( a (-i A) + b (-i B) - c [A ,B] + ...)
    /// = expi( a A + b B - c i [A, B] + ...)
    fn commutator(&self, la: &Op<C<T>>, lb: &Op<C<T>>) -> Op<C<T>>{
        let mut c : Op<C<T>> = la * lb - lb * la;
        c *= -C::i();
        c
    }
}

/// Defines an exponential split for off-diagonal n x n matrices A
/// where exp(A) is the *componentwise* exponent of A
/// and the action of exp(A) on a density matrix rho is componentwise multiplication
pub struct CoherentExpSplit{
    n: usize
}

impl CoherentExpSplit{
    pub fn new(n: u32) -> Self{
        Self{n: n as usize}
    }
}

impl<T: RealScalar> ExponentialSplit<T, C<T>, Op<C<T>>>
for CoherentExpSplit
where C<T>: ComplexScalar<R=T>
{
    type L = Op<C<T>>;
    type LC = LC<C<T>>;
    type U = Op<C<T>>;

    fn lin_zero(&self) -> Self::L {
        Op::zeros(self.n, self.n)
    }

    fn exp(&mut self, l: Op<C<T>>) -> Op<C<T>>{
        let mut e = l;
        e.apply( |x| ComplexField::exp(x) );
        e
    }

    fn map_exp(&mut self, u: & Op<C<T>>, x: &Op<C<T>>) -> Op<C<T>>{
        u.component_mul(x)
    }
}

/// Defines an exponential split for transition rate matrices A.
/// A population conserving transition matrix has the properties
///   1. -A_{ii} \geq 0
///   2. A_{ij} \geq 0,  j\neq i
///   3. \sum_{j} A_{ij} = 0
/// If p is a population vector, then A defines a Markovian kinetic master equation
///  \dv{p}{t} = A p
///
pub struct KineticExpSplit<T: RealScalar>
where C<T>: EigScalar<R=T>
{
    n: usize,
    expm: Expm<C<T>>

}

impl<T: RealScalar> KineticExpSplit<T>
where C<T>: EigScalar<R=T>
{
    pub fn new(n : u32) -> Self{
        Self{n: n as usize, expm: Expm::new(n as usize )}
    }
}

impl<T: RealScalar> ExponentialSplit<T, C<T>, Op<C<T>>> for KineticExpSplit<T>
where C<T>: EigScalar<R=T>
{
    type L = Op<C<T>>;
    type LC = LC<C<T>>;
    type U = Op<C<T>>;

    fn lin_zero(&self) -> Self::L {
        Op::zeros(self.n, self.n)
    }

    fn exp(&mut self, l: Op<C<T>>) -> Op<C<T>>{
        let n = self.n;
        //let re_l = l.map(|x| x.re.to_f64().unwrap() );
        // Construct a array from a *column major* slice
        let arr = ArrayView2::from_shape((n,n), & l.as_slice()).unwrap();
        let mut exp_arr = Array2::zeros((n,n));
        //let mut exp_mat: Op<C<T>> = Op::zeros(n, n);
        self.expm.expm(&arr, &mut exp_arr);

        let exp_map: Op<C<T>> = Op::from_vec(n, n, exp_arr.into_owned().into_raw_vec());
//        for (a, b) in exp_mat.iter_mut()
//                .zip(exp_arr.into_iter()){
//            *a = C::from( T::from_subset( b))
//        }

        exp_map
    }

    fn map_exp(&mut self, u: & Op<C<T>>, x: &Op<C<T>>) -> Op<C<T>>{
        let n = self.n;
        let mut v : Ket<C<T>> = Ket::zeros(n);
        let mut y = x.clone();

        for i in 0..n{ //diagonal iteration
            let k = (n+1)*i;
            v[i] = *x.get(k).unwrap();
        }

        let w = u * v;
        for i in 0..n{ //diagonal iteration
            let k = (n+1)*i;
            y[k] = w[i];
        }

        y
    }
}

pub struct MaybeScalePowExp<T, Sp>
where   T: RealScalar,
        Sp: ExponentialSplit<T, C<T>, Op<C<T>>, L=Op<C<T>>, LC=LC<C<T>>>,
        //Sp::LC : LinearCombination<C<T>, Op<C<T>>>,
        C<T>: ComplexScalar<R=T>
{
    sp: Sp,
    lim: T
}

impl<T, Sp> MaybeScalePowExp<T, Sp>
where   T: RealScalar,
        Sp: ExponentialSplit<T, C<T>, Op<C<T>>, L=Op<C<T>>, LC=LC<C<T>>>,
        //Sp::LC : LinearCombination<C<T>, Op<C<T>>>,
        C<T>: ComplexScalar<R=T>
{
    pub fn new(sp: Sp, lim: T) -> Self{
        Self{sp, lim}
    }

    fn pow_order(&self, x: &Op<C<T>>) -> i64 {
        let (n, _m) = x.shape();
        let mut k = T::zero();
        //assert!(n==m);
        for i in 0..n{
            k = Real::max(k, x.get((n+1)*i).unwrap().abs());
        }

        let d = k / self.lim;
        if d <= T::one(){
            (d+T::one()).to_subset().unwrap() as i64
        } else {
            if d > T::from_subset(&10.0){
                warn!("MaybeScalePowExp: Excessive Iterations ({} / {})", d, self.lim)};
            (d + T::one()).to_subset().unwrap() as i64
        }
    }
}

impl<T, Sp> ExponentialSplit<T, C<T>, Op<C<T>>>
for MaybeScalePowExp<T, Sp>
where   T: RealScalar,
        Sp: ExponentialSplit<T, C<T>, Op<C<T>>, L=Op<C<T>>, LC=LC<C<T>>>,
        //Sp::LC : LinearCombination<C<T>, Op<C<T>>>,
        C<T>: ComplexScalar<R=T>
{
    type L = Sp::L;
    type LC = Sp::LC;
    type U = (Sp::U, i64);

    fn lin_zero(&self) -> Self::L {
        self.sp.lin_zero()
    }

    fn exp(&mut self, l: Self::L) -> Self::U {
        let d = self.pow_order(&l);
        assert!(d > 0);
        if d == 1{
            (self.sp.exp(l), 1)
        } else {
            let mut l = l;
            Self::LC::scale(&mut l,
             C::from(T::from_i64(d).unwrap()).recip());
            let u = self.sp.exp(l);
            (u, d)
        }

    }

    fn map_exp(&mut self, u: &Self::U, x: &Op<C<T>>) -> Op<C<T>> {
        let (u, d) = u;
        let mut x0 : Self::L = x.clone();
        //let mut x1 : &Op<C<T>>;
        for _i in 0..*d{
            let x1 = self.sp.map_exp(u, &x0);
            x0 = x1;
        }
        x0
    }

}

#[cfg(test)]
mod tests{
    use lapacke_sys;
    use num_complex::Complex64 as c64;
    use openblas_src;

    use super::*;

    #[test]
    fn super_op_splits(){
        let _0 = c64::from(0.0);
        let _1 = c64::from(-1.0);
        let mut ksplit = KineticExpSplit::new(3);
        let m1 : Op<c64> = Op::from_row_slice(3, 3,
                                              &[ -_1, _1, _0,
                                                c64::from(0.25), c64::from(-0.25), _0,
                                                _0, _0, _0]);
        let x1 : Op<c64> = Op::from_row_slice(3, 3,
                                              &[_1, _0, _0,
                                                  _0, c64::from(0.5), _0,
                                                  _0, _0, c64::from(1.0) ]);
        let u1 = ksplit.exp(m1.clone());
        let y1 = ksplit.map_exp(&u1, &x1);

        println!(" Rates:\n{}\n\n Exponential:\n{}\n", m1, u1);
        println!(" x1:\n{}\n\n y1:\n{}\n", x1, y1);

    }
}